#ifndef _SIGNALS_H_
#define _SIGNALS_H_

/* Compile time indicator to use Signal Handlers */
#define USE_SIGNAL_HANDLERS 0       /* 1 means use handlers, 0 means no handlers */

/* Prototypes for functions in signals.c */

void regSignals(void (*func)(int));

void signalHandlerLevel1(int sig);

void serverWorkerSignalHandler(int sig);

/**
 * LS$DECODE
 *
 * Linking System utility to decode virtual addresses.
 *
 * This function will be integrated into the LS in SB 8.0
 * (at which point the LS$DECODE OM will be in sys$lib$*linkomlib).
 * At that point, we can remove the LS$DECODE OM from our local files.
 *
 * @param va
 *   A pointer to the one word extended mode virtual address to decode.
 *
 * @param use_ssinfo
 *   A pointer to a flag.
 *   If the flag is true, and if LS$DECODE can't decode the VA,
 *   and it is an app-level VA,
 *   it will attempt to decode it the calling the SSINFO callable interface.
 *   This must be FALSE for now, until the SSINFO code is integrated
 *   into the LS.
 *   Calling SSINFO involves many Exec calls, ERs, C I/O, etc.
 *   If your runtime environment could be unstable,
 *   you should either set this parm to 0,
 *   or ensure that your contingency routine has a good loop stopper.
 *   The output generated by SSINFO is
 *   also longer and of a slightly different form.
 *
 * @param buffer
 *   The address of the buffer where the decoding report is generated.
 *
 * @param bufsize
 *   A pointer to the size of the buffer (in bytes).
 *
 * @param charinx
 *   A pointer to the index in the buffer where to start the report.
 *   0 is the start of the buffer.
 *
 * @return
 *   An int status is returned.
 *   Nonzero implies that something went wrong with the decoding.
 */

#pragma interface LS$DECODE
int LS$DECODE(int * va, int * use_ssinfo, char * buffer, int * bufsize,
              int  *charinx);

#endif /* _SIGNALS_H_ */
