/**
 * File: CycleCmds.c.
 *
 * Functions that process the JDBC Server's CYCLE console handling commands.
 *
 * In the process functions in this file:
 *
 *   - A return of 1 means that the textMessage
 *     string (in sgd) contains the message to be returned via ER COM$
 *     to the @@CONS command sender.
 *     The caller must send the reply.
 *
 *   - A return of 0 means that the reply has already been sent.
 */

/* Standard C header files and OS2200 System Library files */
#include <ertran.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <task.h>
#include <universal.h>
#include "marshal.h"

/* JDBC Project Files */
#include "server-msg.h" /* Include crosses the c-interface/server boundary */
#include "ConsoleCmds.h"
#include "CycleCmds.h"
#include "DisplayCmds.h"
#include "ProcessTask.h"
#include "Server.h"
#include "ServerConsol.h"
#include "ServerLog.h"
#include "ServiceUtils.h"

/* Imported data */

extern serverGlobalData sgd;
    /* The Server Global Data (SGD), visible to all Server activities. */

/* #defines */
#define SERVER_LOG_TYPE 1
#define SERVER_TRACE_TYPE 2
#define CLIENT_TRACE_TYPE 3


#define NEW_FCYCLE_TEMP_USE_NAME "JDBC$CYCLE$1"
#define NEW_FCYCLE_TEMP_USE_NAME2 "JDBC$CYCLE$2"
#define OLD_FCYCLE_TEMP_USE_NAME "JDBC$CYCLE$3"

/* CYCLE command
   ------------- */

/**
 * Function processCycleCmd
 *
 * Process the CYCLE commands
 * (log and trace file control commands).
 *
 *   CYCLE SERVER LOG FILE
 *   CYCLE SERVER TRACE FILE
 *   CYCLE CLIENT id|tid TRACE FILE (available only for Local Server)
 *   CYCLE CLIENT TRACE FILE        (available only for XA Server)
 *
 * @param msg
 *   The @@CONS command text.
 *
 * @return
 *   A status:
 *     - 0: The console reply has already been sent.
 *     - 1: The caller calls replyToKeyin to print the reply in
 *          sgd.textMessage.
 */

int processCycleCmd(char *msg) {

    int cmdStatus;
    char msgBuffer[SERVER_ERROR_MESSAGE_BUFFER_LENGTH+1]; /* Maximal room for an error message. */
    char * msg2;

    if (strcmp(msg,"CYCLE SERVER LOG FILE") == 0) {
        cmdStatus = processCycleFileCmd(msg, SERVER_LOG_TYPE);
    } else if (strcmp(msg,"CYCLE SERVER TRACE FILE") == 0) {
        cmdStatus = processCycleFileCmd(msg, SERVER_TRACE_TYPE);
    } else if (strncmp(msg,"XCYCLE CLIENT", 13) == 0) {         /* Disable this for now - needs to be updated */
        cmdStatus = processCycleFileCmd(msg, CLIENT_TRACE_TYPE);
    } else {
        msg2 = getLocalizedMessageServer(CH_INVALID_CYCLE_CMD, NULL, NULL, 0, msgBuffer);
            /* 5201 Invalid CYCLE command */
        strcpy(sgd.textMessage, msg2);
        cmdStatus = 1;
    }

    return cmdStatus;

} /* processCycleCmd */

/**
 * Function processCycleFileCmd
 *
 * F-cycle the server log file, server trace file, or a client trace file.
 *
 * The commands are:
 *
 *   CYCLE SERVER LOG FILE
 *   CYCLE SERVER TRACE FILE
 *   CYCLE CLIENT id|tid TRACE FILE     (available only for Local Server)
 *   CYCLE CLIENT TRACE FILE        (available only for XA Server)
 *
 * id (if specified) is the server worker socket ID.
 * This is H1 (the upper 18 bits) in the WDE's socket ID word,
 * specified in decimal.
 * This id value is listed under "server work socket id",
 * which is the first line of output for each server worker,
 * as generated by the console command DISPLAY WORKER STATUS.
 *
 * tid (if specified) is the server worker RDMS thread name.
 * This is in the WDE's threadname character array.
 *
 * Here is the exact sequence of steps needed to take an existing file that is being
 * written to (server log file, server trace file, or a client trace file),
 * cycle that file to the next file cycle, and switch over
 * to use the new file cycle:
 *
 *    1. Get the qualifier and file name of the existing file in fullFileName
 *         (e.g., the server log file).
 *    1a.Set oldAbsFCycle to the absolute file cycle of the current file
 *         (use ER FITEM$ on useName)
 *    1b.@USE JDBC$CYCLE$3,qual*file(oldAbsFCycle)
 *    2. @ASG,CPZ qual*file(+1),///1000
 *         (the new file cycle is not catalogued until it is @FREEd)
 *    3. @USE JDBC$CYCLE$1,qual*file(+1)
 *    4. Set absFCycle to the absolute file cycle of the new file
 *         (use ER FITEM$ on the USE name JDBC$CYCLE$1).
 *    5. @USE JDBC$CYCLE$2,qual*file(absFCycle)
 *    6. @FREE,R qual*file(+1)
 *         (thus causing the new file cycle to be catalogued)
 *    7. Open the new file cycle via fopen("JDBC$CYCLE$2", "a")
 *         and set FILE pointer localFilePtr.
 *    8. Save the appropriate FILE pointer for the old file cycle
 *         in saveOldFilePtr
 *         (e.g., save sgd.serverLogFile for the server log file).
 *    9. Set the global FILE pointer to point to the new file cycle
 *         whose FILE pointer is in localFilePtr
 *         (e.g., set sgd.serverLogFile for the server log file).
 *   10. @USE global-use-name,qual*file(abs-f-cycle)
 *         (e.g., global-use-name is JDBC$LOG for the server log file)
 *   11. Close the old file cycle via fclose(saveOldFilePtr).
 *   11a.@FREE,A JDBC$CYCLE$1
 *         (free the first temporary USE name for the new F-cycle)
 *   11b.@FREE,A JDBC$CYCLE$2
 *         (free the second temporary USE name for the new F-cycle)
 *   11c.@FREE,AR JDBC$CYCLE$3
 *         (free the old F-cycle and its temporary USE name)
 *   12. Write config info to the new file cycle.
 *       In addition, for a client trace file,
 *       write worker info to the new file cycle.
 *
 * This exact sequence is important, because of problems encountered with
 * handling updated file cycles in the Exec.
 *
 * @param msg
 *   The console command.
 *
 * @param cmdType
 *   A status that describes the type of file to be cycled:
 *     - SERVER_LOG_TYPE
 *     - SERVER_TRACE_TYPE
 *     - CLIENT_TRACE_TYPE
 *
 * @return
 *   A status:
 *     - 0: The console reply has already been sent.
 *     - 1: The caller calls replyToKeyin to print the reply in
 *          sgd.textMessage.
 */

static int processCycleFileCmd(char * msg, int cmdType) {

    char workerID_or_tid[80];  /* also make large enough */
    char tid[80]; /* large enough for thread name (and even the whole CH command). */
    int workerID;
    int status;
    int absFCycle;
    int oldAbsFCycle;
    int oldUseSucceeded = TRUE;
    int logIndicator;
    workerDescriptionEntry *wdePtr = NULL;
    FILE ** filePtrPtr;
    FILE * saveOldFilePtr;
    FILE * localFilePtr;
    tsq_cell * TSCellPtr;
    char * fileName;
    char msgInsert[30];
        /* msgInsert used for "server log", "server trace",
           or "client <id> trace" */
    char useName[USERID_NAME_FIELD_LEN+1];
    char fullFileName[MAX_FILE_NAME_LEN+1];
    char ACSFString[MAX_ACSF_STRING_SIZE+1];
    char * msg2;
    char digits[ITOA_BUFFERSIZE];
    char msgBuffer[SERVER_ERROR_MESSAGE_BUFFER_LENGTH+1]; /* Maximal room for an error message. */

#ifndef XABUILD /* Local Server */

    char insert1[TRAILING_STRING_SIZE];
    char insert2[TRAILING_STRING_SIZE];

    /* The following is used to detect garbage following what looks
       like legal command syntax.
       If that case is detected, the command is ignored. */
    char trail[TRAILING_STRING_SIZE];

#endif /* Local Server */

    /* assume socket id in a 5203 message (default for XA Server and JDBC Server) */
    strcpy(workerID_or_tid,"socket ID ");

    /* Initialization */
    switch (cmdType) {

        /* CYCLE SERVER LOG FILE */
        case SERVER_LOG_TYPE:
            strcpy(msgInsert, "server log");
            filePtrPtr = &(sgd.serverLogFile);
            fileName = sgd.serverLogFileName;
            strcpy(useName, LOG_FILE_USE_NAME);
            TSCellPtr = &(sgd.serverLogFileTS);
            logIndicator = TO_SERVER_LOGFILE;
            break;

        /* CYCLE SERVER TRACE FILE */
        case SERVER_TRACE_TYPE:
            /* If Server trace filename is PRINT$, we do not cycle it. */
            if (strcmp(sgd.serverTraceFileName, PRINT$_FILE) == 0){
                msg2 = getLocalizedMessageServer(CH_CYCLING_PRINT$_NOT_ALLOWED,
                                                 NULL, NULL, 0, msgBuffer);
                          /* 5253 File cycling of PRINT$ not allowed */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            strcpy(msgInsert, "server trace");
            filePtrPtr = &(sgd.serverTraceFile);
            fileName = sgd.serverTraceFileName;
            strcpy(useName, TRACE_FILE_USE_NAME);
            TSCellPtr = &(sgd.serverTraceFileTS);
            logIndicator = TO_SERVER_TRACEFILE;
            break;

        /* CYCLE CLIENT id|tid TRACE FILE */
        case CLIENT_TRACE_TYPE:

#ifdef XABUILD /* XA Server */

        /* CYCLE CLIENT TRACE FILE */

            if (strcmp(msg, "CYCLE CLIENT TRACE FILE") == 0) {
                workerID = magicSocketID;
                strcpy(tid, magicSocketID_as_string);
                    /* Set this value for the findWorker call below.
                       This causes us to get the first (only) WDE entry for
                       the XA Server.
                       This is needed since there is no ID field in the
                       command for the XA case.  */

#else /* Local Server */

        /* CYCLE CLIENT id|tid TRACE FILE */

            if (sscanf(msg, "CYCLE CLIENT %s %s %s %s", &tid, &insert1,
                    &insert2, &trail) == 3) {

                if ((strcmp(insert1, "TRACE") != 0) ||
                        (strcmp(insert2, "FILE") != 0)) {
                    msg2 = getLocalizedMessageServer(
                        CH_INVALID_CYCLE_CLIENT_CMD, NULL, NULL, 0, msgBuffer);
                            /* 5202 Invalid CYCLE CLIENT TRACE FILE command */
                    strcpy(sgd.textMessage, msg2);
                    return 1;
                }

            /* Determine if the tid is a socket id (id) or a thread name (tid) */
            strcpy(workerID_or_tid,"socket ID "); /* assume socket id in message */
            if (sscanf(tid,"%d%s",&workerID, &trail) != 1){
               /* Not a socket id (id), assume its a thread name, find its workerID */
               findWorker_by_RDMS_threadname(tid,&workerID);
               strcpy(workerID_or_tid,"RDMS thread name "); /* assume thread name in message*/
            }

#endif

            } else {
                msg2 = getLocalizedMessageServer(
                    CH_INVALID_CYCLE_CLIENT_CMD, NULL, NULL, 0, msgBuffer);
                        /* 5202 Invalid CYCLE CLIENT TRACE FILE command */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            if ((workerID <= 0)
                && (workerID != magicSocketID)) {

                    /* Special negative constant causes the first client
                       with a non-zero socket ID to be picked.
                       This is for development only,
                       and is not documented for users.

                       For the XA Server case,
                       the command has no ID field,
                       but we substituted the magicSocketID value above,
                       so as to get the first (i.e., only) WDE entry.
                       */

                msg2 = getLocalizedMessageServer(CH_INVALID_WORKER_ID,
                    workerID_or_tid, tid, 0, msgBuffer);
                    /* 5203 Client {0} {1} not found */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            /* We have valid command syntax.
               Now check for a valid worker ID.
               This is in H1 (the upper 18 bits) in the WDE's socket ID word,
               specified in decimal.
               This id value is listed under "server work socket id",
               which is the first line of output for each server worker,
               as generated by the console command DISPLAY WORKER STATUS.

               For the XA case, simply return the only WDE entry.
               */

            status = findWorker(&workerID, &wdePtr);

            if (status == 0) {
                /* We found the worker (id) for the CYCLE CLIENT command.
                   Set up variables used in common code (which handles the
                   server trace file and the client trace file) below.
                   */

#ifdef XABUILD /* XA Server */

                strcpy(msgInsert, "client trace");

#else /* Local Server */

                sprintf(msgInsert, "client %s trace", tid);

#endif

                /* If no client trace file exists,
                   then generate an error and return. */
                if (wdePtr->clientTraceFileNbr == 0) {
                    msg2 = getLocalizedMessageServer(CH_NO_CYCLING_POSSIBLE,
                        msgInsert, NULL, 0, msgBuffer);
                        /* 5204 No {0} file exists; file cycling not possible */
                    strcpy(sgd.textMessage, msg2);
                    return 1;
                }

                filePtrPtr = &(wdePtr->clientTraceFile);
                fileName = wdePtr->clientTraceFileName;

                /* If client trace filename is PRINT$, we do not cycle it. */
                if (strcmp(wdePtr->clientTraceFileName, PRINT$_FILE) == 0){
                    msg2 = getLocalizedMessageServer(CH_CYCLING_PRINT$_NOT_ALLOWED,
                                                     NULL, NULL, 0, msgBuffer);
                              /* 5253 File cycling of PRINT$ not allowed */
                    strcpy(sgd.textMessage, msg2);
                    return 1;
                }

                TSCellPtr = &(sgd.serverLogFileTS);
                    /* There is no T/S cell for the client trace file,
                       so instead use the server log file's T/S cell. */

                logIndicator = TO_CLIENT_TRACEFILE;

                /* Set up USE name for the client trace file */
                sprintf(useName, "%s%d", CLIENT_TRACE_FILE_USE_NAME_PREFIX,
                    wdePtr->clientTraceFileNbr);

            } else {
                msg2 = getLocalizedMessageServer(CH_INVALID_WORKER_ID,
                    workerID_or_tid, tid, 0, msgBuffer);
                    /* 5203 Client {0} {1} not found */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            break; /* end of client trace file case */
    } /* end switch */

    /* See if we have a nonempty filename string.
       Note: We can't just test the FILE pointer (for NULL),
       since (at least for a server trace file or client trace file)
       trace could have been turned off (via a TURN OFF command).
       */
    if (strlen(fileName) == 0) {
        msg2 = getLocalizedMessageServer(CH_NO_CYCLING_POSSIBLE, msgInsert,
            NULL, 0, msgBuffer);
                /* 5204 No {0} file exists; file cycling not possible */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 1.
       Get the full qualifier*filename, with no F-cycle
       */
    getFullFileName(useName, fullFileName, FALSE);

    if (strlen(fullFileName) == 0) {
        msg2 = getLocalizedMessageServer(CH_NO_NEW_CYCLE_CREATED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5205 Could not create a new F-cycle of the {0} file */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 1a.
       Get the absolute F cycle of the current (old) file cycle.
       Function getFileCycle calls ER FITEM$.
       */
    oldAbsFCycle = getFileCycle(useName);

    /* Step 1b.
       Get a USE name for the old F cycle, using the absolute file cycle.
       @USE JDBC$CYCLE$3,qual*file(oldAbsFCycle)
       This USE name will be used to free the old file cycle.
       */
    sprintf(ACSFString, "@USE %s,%s(%d) . ",
        OLD_FCYCLE_TEMP_USE_NAME, fullFileName, oldAbsFCycle);

    status = doACSF(ACSFString);

    if (status < 0) {
        oldUseSucceeded = FALSE;
    }

    /* Step 2.
       Get the new file cycle:
         @ASG,CPZ qual*file(+1),///9999
       Note that the new F cycle is not catalogued until we @FREE it below.
       */
    sprintf(ACSFString, "@ASG,CPZ %s(+1),///%d . ", fullFileName,
        ASG_FILE_TRACK_SIZE);

    status = doACSF(ACSFString);

    if (status < 0) {
        msg2 = getLocalizedMessageServer(CH_NO_NEW_CYCLE_CREATED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5205 Could not create a new F-cycle of the {0} file */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 3.
       Get a USE name for the new F cycle:
         @USE JDBC$CYCLE$1,qual*file(+1)
       We need this USE name in order to do an FITEM on the new file cycle,
       so if the USE fails, abort the CYCLE command.
       This USE name is valid only until we @FREE the new F cycle.
       */
    sprintf(ACSFString, "@USE %s,%s(+1) . ", NEW_FCYCLE_TEMP_USE_NAME,
        fullFileName);

    status = doACSF(ACSFString);

    if (status < 0) {
        msg2 = getLocalizedMessageServer(CH_NO_NEW_CYCLE_CREATED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5205 Could not create a new F-cycle of the {0} file */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 4.
       Get the absolute F cycle of the new file cycle.
       Function getFileCycle calls ER FITEM$.
       */
    absFCycle = getFileCycle(NEW_FCYCLE_TEMP_USE_NAME);

    /* Step 5.
       Get a USE for the new F cycle, using the absolute file cycle.
         @USE JDBC$CYCLE$2,qual*file(abs-f-cycle)
       This USE name will be valid after we @FREE the new F cycle.
       If the USE fails, abort the CYCLE command.
       */
    sprintf(ACSFString, "@USE %s,%s(%d) . ",
        NEW_FCYCLE_TEMP_USE_NAME2, fullFileName, absFCycle);

    status = doACSF(ACSFString);

    if (status < 0) {
        msg2 = getLocalizedMessageServer(CH_NO_NEW_CYCLE_CREATED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5205 Could not create a new F-cycle of the {0} file */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 6.
       @FREE the new F cycle of the file:
         @FREE,R qual*file(+1)
       After the @FREE, the new F cycle is catalogued,
       and we can use it for UC I/O.
         */
    sprintf(ACSFString, "@FREE,R %s(+1) . ", fullFileName);

    status = doACSF(ACSFString);

    if (status < 0) {
        msg2 = getLocalizedMessageServer(CH_NO_NEW_CYCLE_CREATED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5205 Could not create a new F-cycle of the {0} file */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 7.
       Open the new file cycle for UC I/O via fopen().
       Append ("a") mode causes the new file to be opened at the top.
       A call to fopenWithErase() is not needed,
       since the file is new.
       */
    localFilePtr = fopen(NEW_FCYCLE_TEMP_USE_NAME2, "a");

    if (localFilePtr == NULL) {
        msg2 = getLocalizedMessageServer(CH_NEW_CYCLE_NOT_OPENED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5206 Could not open the new F-cycle of the {0} file */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Step 8.
       Save the appropriate FILE pointer for the old file cycle
       in saveOldFilePtr
       (e.g., save sgd.serverLogFile for the server log file).
       */
    saveOldFilePtr = *filePtrPtr;

    /* Step 9.
       Set the appropriate FILE pointer to localFilePtr (used on the fopen).
       This moves the appropriate log or trace file to the new file cycle
       of the file
       (e.g., set sgd.serverLogFile for the server log file).
       */
    if (TSCellPtr != NULL) {
        test_set(TSCellPtr); /* Set the appropriate T/S cell */
    }

    *filePtrPtr = localFilePtr;

    if (TSCellPtr != NULL) {
        ts_clear_act(TSCellPtr); /* Clear T/S cell */
    }

    /* Step 10.
       Set the appropiate global USE name (for the log / trace file):
         @USE use-name,qual*file(abs-f-cycle)
       E.g., use-name is JDBC$LOG for the server log file
       and JDBC$TRACE for the server trace file.
       The @USE should never fail, since the filename is valid,
       but check anyway.
       */

    sprintf(ACSFString, "@USE %s,%s(%d) . ", useName, fullFileName, absFCycle);

    status = doACSF(ACSFString);

    if (status < 0) {
        msg2 = getLocalizedMessageServer(CH_TRACE_FILE_USE_FAILED, msgInsert,
            itoa(status, digits, 8), SERVER_LOGS, msgBuffer);
            /* 5207 @USE on {0} trace file name failed; octal status {1} */
        strcpy(sgd.textMessage, msg2);
    }

    /* Step 11.
       Close the old file cycle,
       since we have switched over to the new file cycle.
       */
    if (saveOldFilePtr != NULL) {
        status = fclose(saveOldFilePtr);

        if (status < 0) {
            msg2 = getLocalizedMessageServer(CH_FCLOSE_FAILED_FOR_F_CYCLE,
                msgInsert, itoa(status, digits, 8), SERVER_LOGS, msgBuffer);
                    /* 5208 fclose() failed on old file cycle of {0};
                       octal status {1} */
            strcpy(sgd.textMessage, msg2);
        }
    }

    /* Step 11a.
       @FREE,A JDBC$CYCLE$1
       (free the first temporary USE name for the new F-cycle)
       The @FREE should never fail, since the USE name is valid.
       */

    sprintf(ACSFString, "@FREE,A %s . ", NEW_FCYCLE_TEMP_USE_NAME);

    status = doACSF(ACSFString);

    /* Step 11b.
       @FREE,A JDBC$CYCLE$2
       (free the second temporary USE name for the new F-cycle)
       The @FREE should never fail, since the USE name is valid.
       */

    sprintf(ACSFString, "@FREE,A %s . ", NEW_FCYCLE_TEMP_USE_NAME2);

    status = doACSF(ACSFString);

    /* Step 11c.
       @FREE,AR JDBC$CYCLE$3
       (free the old F-cycle and its temporary USE name).
       This should never fail.
       The free of the old F-cycle is needed for the case
       where the user exclusively assigned the file
       in the runserver add stream.
       Without this free, there is no way to look at the old file cycle
       (after the console cycle command is complete) from another run.
       */

    if (oldUseSucceeded) {
        sprintf(ACSFString, "@FREE,AR %s . ", OLD_FCYCLE_TEMP_USE_NAME);

        status = doACSF(ACSFString);
    }

    /* Step 12.
       Add config info to the new file cycle.
       If the file is a client trace file,
       also add server worker info to the new file cycle.
       */
    if (cmdType == CLIENT_TRACE_TYPE) {
        clientTraceFileInit(wdePtr);
    } else {
        processDisplayConfigurationCmd(TRUE, logIndicator, FALSE, wdePtr);
    }

    /* Set up a message for a successful command:
       File cycle <n> of the <log / trace> file was created
       This message is in sgd.textMessage, which is printed by the caller.
       The message is printed as follows:
         - The caller prints the message to the sender of the @@CONS command.
         - Add an entry to the server log file,
           indicating that the value was changed
           (unless flag sgd.logConsoleOutput is TRUE,
           in which case the console output is
           already being sent to the log file).
         - The message goes to the server's stdout file.
           addServerLogEntry's logIndicator argument controls
           the server log file and stdout.
         - If we have the command 'CYCLE CLIENT id TRACE FILE'
           add an entry to the client trace file.
       */

    /* Set up log indicator for the call to addServerLogEntry
       (via the call to getLocalizedMessageServer) */
    if (sgd.logConsoleOutput) {
        logIndicator = TO_SERVER_STDOUT; /* stdout only */
    } else {
        logIndicator = SERVER_LOGS; /* log file and stdout */
    }

    msg2 = getLocalizedMessageServer(CH_F_CYCLE_CREATED,
        itoa(absFCycle, digits, 10), msgInsert, 0, msgBuffer);
        /* 5209 File cycle {0} of the {1} file was created */
    checkForDigit(sgd.textMessage, msg2);
        /* Eliminate the message number at the start of the message */
    addServerLogEntry(logIndicator, sgd.textMessage);

    /*
     * Get the new log file name for use in Console messages when server is shutting 
     * down in error. Store this value in sgd for use by other modules.
     */
    getFullFileName(LOG_FILE_USE_NAME, sgd.fullLogFileName, TRUE);

    if (wdePtr != NULL) {
        addClientTraceEntry(wdePtr, TO_CLIENT_TRACEFILE, sgd.textMessage);
    }

    /* Return 1, which tells the caller to print the message in
       sgd.textMessage
       */
    return 1;

} /* processCycleFileCmd */
