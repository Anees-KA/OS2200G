/**
 * File: TurnCmds.c.
 *
 * Functions that process the JDBC Server's console handling
 * commands to TURN ON and TURN OFF log and trace output..
 *
 * In the process functions in this file:
 *
 *   - A return of 1 means that the textMessage
 *     string (in sgd) contains the message to be returned via ER COM$
 *     to the @@CONS command sender.
 *     The caller must send the reply.
 *
 *   - A return of 0 means that the reply has already been sent.
 */

/* Standard C header files and OS2200 System Library files */
#include <ertran.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <task.h>
#include <ctype.h>
#include <universal.h>
#include "marshal.h"

/* JDBC Project Files */
#include "server-msg.h" /* Include crosses the c-interface/server boundary */
#include "ConsoleCmds.h"
#include "ProcessTask.h"
#include "Server.h"
#include "ServerConsol.h"
#include "ServerLog.h"
#include "ServiceUtils.h"
#include "TurnCmds.h"

/* Imported data */

extern serverGlobalData sgd;
    /* The Server Global Data (SGD), visible to all Server activities. */

/* TURN ON and TURN OFF commands
   ----------------------------- */

/**
 * Function processTurnCmd
 *
 * Process the TURN ON and TURN OFF commands.
 * (log and trace file control commands).
 *
 *   TURN ON SERVER TRACE
 *   TURN OFF SERVER TRACE
 *   TURN ON CLIENT id|tid TRACE    (only for Local Server)
 *   TURN OFF CLIENT id|tid TRACE   (only for Local Server)
 *   TURN ON CLIENT TRACE       (only for XA Server)
 *   TURN OFF CLIENT TRACE      (only for XA Server)
 *   TURN ON MRF                ("hidden" console command)
 *   TURN OFF MRF               ("hidden" console command)
 *
 * id (if specified) is the server worker socket ID.
 * This is in H1 (the upper 18 bits) in the WDE's socket ID word
 * (client_socket), specified in decimal.
 * This id value is listed under "server work socket id",
 * which is the first line of output for each server worker,
 * as generated by the console command DISPLAY WORKER STATUS.
 *
 * @param msg
 *   The @@CONS command text.
 *
 * @return
 *   A status:
 *     - 0: The console reply has already been sent.
 *     - 1: The caller calls replyToKeyin to print the reply in
 *          sgd.textMessage.
 */

int processTurnCmd(char * msg) {

    int cmdStatus;
    char * msg2;
    char msgBuffer[SERVER_ERROR_MESSAGE_BUFFER_LENGTH+1]; /* Maximal room for an error message. */

    if (strcmp(msg,"TURN ON SERVER TRACE") == 0) {
        cmdStatus = processTurnTraceCmd(msg, TRUE, FALSE);
    } else if (strcmp(msg,"TURN OFF SERVER TRACE") == 0) {
        cmdStatus = processTurnTraceCmd(msg, FALSE, FALSE);
    } else if (strncmp(msg,"XTURN ON CLIENT", 15) == 0) {
        cmdStatus = processTurnTraceCmd(msg, TRUE, TRUE);
    } else if (strncmp(msg,"XTURN OFF CLIENT", 16) == 0) {
        cmdStatus = processTurnTraceCmd(msg, FALSE, TRUE);
    } else if (strncmp(msg,"TURN ON MRF", 11) == 0) {
        /* To turn on multi-row-fetch we must be RDMS 19R1 or higher */
        if ((sgd.rdmsBaseLevel > RDMS_BASE_LEVEL_18)){
            sgd.FFlag_SupportsFetchToBuffer = 1;  /* Multi-row-fetch is supported, turn on its usage. */
            strcpy(sgd.textMessage, "Multi-record-fetch feature turned on");
            cmdStatus = 1;
        }
    } else if (strncmp(msg,"TURN OFF MRF", 12) == 0) {
        sgd.FFlag_SupportsFetchToBuffer = 0;  /* Turn off use of multi-row-fetch api. */
        strcpy(sgd.textMessage, "Multi-record-fetch feature turned off");
        cmdStatus = 1;
    } else {
        msg2 = getLocalizedMessageServer(CH_INVALID_TURN_CMD, NULL, NULL, 0, msgBuffer);
            /* 5237 Invalid TURN ON / OFF command */
        strcpy(sgd.textMessage, msg2);
        cmdStatus = 1;
    }
    return cmdStatus;
} /* processTurnCmd */

/**
 * Function processTurnTrace
 *
 * Turn print on or off in the server trace file or a client's trace file.
 * The commands are:
 *
 *   TURN ON SERVER TRACE
 *   TURN OFF SERVER TRACE
 *   TURN ON CLIENT id|tid TRACE    (only for Local Server)
 *   TURN OFF CLIENT id|tid TRACE   (only for Local Server)
 *   TURN ON CLIENT TRACE       (only for XA Server)
 *   TURN OFF CLIENT TRACE      (only for XA Server)
 *
 * id (if specified) is the server worker socket ID.
 * This is in H1 (the upper 18 bits) in the WDE's socket ID word
 * (client_socket), specified in decimal.
 * This id value is listed under "server work socket id",
 * which is the first line of output for each server worker,
 * as generated by the console command DISPLAY WORKER STATUS.
 *
 * tid (if specified) is the server worker RDMS thread name.
 * This is in the WDE's threadname character array.
 *
 * @param msg
 *   The console command.
 *
 * @param isTurnOnCmd
 *   A flag that is TRUE if the command is on of the TURN ON commands,
 *   and FALSE if one of the TURN OFF commands.
 *
 * @param isClientTraceFile
 *   A flag that is TRUE if print is to be turned on in a client's
 *   trace file,
 *   and FALSE if print is to be turned on in the server trace file.
 *
 * @return
 *   A status:
 *     - 0: The console reply has already been sent.
 *     - 1: The caller calls replyToKeyin to print the reply in
 *          sgd.textMessage.
 */

static int processTurnTraceCmd(char * msg, int isTurnOnCmd, int isClientTraceFile) {

    char workerID_or_tid[80];  /* also make large enough */
    char tid[80]; /* large enough for thread name (and even the whole CH command). */
    int useErr;
    int closeErr;
    int workerID;
    int status;
    int logIndicator;
    FILE ** filePtrPtr;
    FILE * localFilePtr;
    char * fileName;
    char useName[USERID_NAME_FIELD_LEN+1];
    char msgInsert[80]; /* "client <id>|<tid>" or "server" */
    workerDescriptionEntry *wdePtr = NULL;
    char * msg2;
    char digits[ITOA_BUFFERSIZE];
    char msgBuffer[SERVER_ERROR_MESSAGE_BUFFER_LENGTH+1]; /* Maximal room for an error message. */

#ifndef XABUILD /* Local Server */

    char insert[TRAILING_STRING_SIZE];

    /* The following is used to detect garbage following what looks
       like legal command syntax.
       If that case is detected, the command is ignored. */
    char trail[TRAILING_STRING_SIZE];

#endif /* Local Server

    /* assume socket id in a 5203 message (default for XA Server and JDBC Server) */
    strcpy(workerID_or_tid,"socket ID ");

    /* Set up log indicator for the call to addServerLogEntry */
    if (sgd.logConsoleOutput) {
        logIndicator = TO_SERVER_STDOUT; /* stdout only */
    } else {
        logIndicator = SERVER_LOGS; /* log file and stdout */
    }

    /* CLIENT case.
       Do some processing for the commands
           TURN ON CLIENT id TRACE
           TURN OFF CLIENT id TRACE
       First pick up the id field.
       These commands are for the Local Server.

       Also perform processing for the commands
           TURN ON CLIENT TRACE
           TURN OFF CLIENT TRACE
       These commands are for the XA Server.
       */

    if (isClientTraceFile == TRUE) {

#ifdef XABUILD /* XA Server */

        if ((strcmp(msg, "TURN ON CLIENT TRACE") == 0)
            || (strcmp(msg, "TURN OFF CLIENT TRACE") == 0)) {

            workerID = magicSocketID;
            strcpy(tid, magicSocketID_as_string);
                /* Set this value for the findWorker call below.
                   This causes us to get the first (only) WDE entry for
                   the XA Server.
                   This is needed since there is no ID field in the
                   command for the XA case.

                   Note: Parameter isTurnOnCmd determines the TURN ON or
                   TURN OFF command. */

#else /* Local Server */

        if (sscanf(msg, "TURN ON CLIENT %s %s %s", &tid, &insert, &trail)
            == 2) {

            if (strcmp(insert, "TRACE") != 0) {
                msg2 = getLocalizedMessageServer(CH_INVALID_TURN_ON_CLIENT_CMD,
                    NULL, NULL, 0, msgBuffer);
                        /* 5238 Invalid TURN ON CLIENT command */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            /* Determine if the tid is a socket id (id) or a thread name (tid) */
            if (sscanf(tid,"%d%s",&workerID, &trail) != 1){
               /* Not a socket id (id), assume its a thread name, find its workerID */
               findWorker_by_RDMS_threadname(tid, &workerID);
               strcpy(workerID_or_tid,"RDMS thread name "); /* assume thread name in message*/
            }

        } else if (sscanf(msg, "TURN OFF CLIENT %s %s %s", &tid, &insert,
            &trail) == 2) {

            if (strcmp(insert, "TRACE") != 0) {
                msg2 = getLocalizedMessageServer(
                    CH_INVALID_TURN_OFF_CLIENT_CMD, NULL, NULL, 0, msgBuffer);
                        /* 5239 Invalid TURN OFF CLIENT command */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            /* Determine if the tid is a socket id (id) or a thread name (tid) */
            if (sscanf(tid,"%d%s",&workerID, &trail) != 1){
               /* Not a socket id (id), assume its a thread name, find its workerID */
               findWorker_by_RDMS_threadname(tid, &workerID);
               strcpy(workerID_or_tid,"RDMS thread name "); /* assume thread name in message*/
            }


#endif

        } else {
            msg2 = getLocalizedMessageServer(
                CH_INVALID_TURN_ON_OFF_CLIENT_CMD, NULL, NULL, 0, msgBuffer);
                    /* 5240 Invalid TURN ON / OFF CLIENT command */
            strcpy(sgd.textMessage, msg2);
            return 1;
        }

        if ((workerID <= 0)
            && (workerID != magicSocketID)) {

                /* Special negative constant causes the first client
                   with a non-zero socket ID to be picked.
                   This is for development only,
                   and is not documented for users.

                   For the XA Server case,
                   the command has no ID field,
                   but we substituted the magicSocketID value above,
                   so as to get the first (i.e., only) WDE entry.
                   */

            msg2 = getLocalizedMessageServer(CH_INVALID_WORKER_ID,
                workerID_or_tid, tid, 0, msgBuffer);
                /* 5203 Client {0} {1} not found */
            strcpy(sgd.textMessage, msg2);
            return 1;
        }

        /* We have valid command syntax.
           Now check for a valid worker ID.
           This is in H1 (the upper 18 bits) in the WDE's socket ID word
           (client_socket), specified in decimal.
           This id value is listed under "server work socket id",
           which is the first line of output for each server worker,
           as generated by the console command DISPLAY WORKER STATUS.

           For the XA case, simply return the only WDE entry.
           */

        status = findWorker(&workerID, &wdePtr);

        if (status == 0) {
            /* We found the worker (id|tid) for the
               TURN ON CLIENT TRACE or
               TURN OFF CLIENT TRACE command.
               Set up variables used in common code (which handles the
               server trace file and the client trace file) below.
               */

#ifdef XABUILD /* XA Server */

            strcpy(msgInsert, "client");

#else /* Local Server */

            sprintf(msgInsert, "client %s", tid);

#endif

            /* See if a client trace file exists. */
            if (wdePtr->clientTraceFileNbr == 0) {
                msg2 = getLocalizedMessageServer(CH_NO_TRACE_FILE_SPECIFIED,
                    msgInsert, NULL, 0, msgBuffer);
                        /* 5245 No {0} trace file exists */
                strcpy(sgd.textMessage, msg2);
                return 1;
            }

            filePtrPtr = &(wdePtr->clientTraceFile);
            fileName = wdePtr->clientTraceFileName;

            /* Set up USE name for the client trace file */
            sprintf(useName, "%s%d", CLIENT_TRACE_FILE_USE_NAME_PREFIX,
                wdePtr->clientTraceFileNbr);

        } else {
            msg2 = getLocalizedMessageServer(CH_INVALID_WORKER_ID,
                workerID_or_tid, tid, 0, msgBuffer);
                /* 5203 Client {0} {1} not found */
            strcpy(sgd.textMessage, msg2);
            return 1;
        }

    } else {
        /* SERVER case.
           Set up variables used in common code (which handles the
           server trace file and the client trace file) below.
           */
        strcpy(msgInsert, "server");
        filePtrPtr = &(sgd.serverTraceFile);
        fileName = sgd.serverTraceFileName;
        strcpy(useName, TRACE_FILE_USE_NAME);
    }

    /* Common processing for the 'TURN OFF' commands
       ('TURN OFF SERVER TRACE' and 'TURN OFF CLIENT id|tid TRACE').
       Close the file, and set the FILE pointer to NULL.
       */
    if (isTurnOnCmd == FALSE) {

        if (*filePtrPtr == NULL) {
            msg2 = getLocalizedMessageServer(CH_TRACE_ALREADY_OFF, msgInsert,
                NULL, 0, msgBuffer);
                    /* 5241 The {0} trace is already turned off */
            strcpy(sgd.textMessage, msg2);
            return 1;
        }

        /* Close the file and set the FILE pointer to NULL,
           all under T/S.
           Since the client trace file does not have its own T/S cell,
           use the server log file's T/S cell for that case. */
        if (isClientTraceFile) {
            test_set(&(sgd.serverLogFileTS)); /* Set the log file's T/S cell */
        } else {
            test_set(&(sgd.serverTraceFileTS)); /* Set the trace file's T/S cell */
        }

        /* Is the file name PRINT$? */
        if ((strcmp(fileName, PRINT$_FILE) == 0)){
            /* PRINT$ is never closed. */
            closeErr = 0;
        } else {
            /* Close the trace file */
            closeErr = fclose(*filePtrPtr);
        }

        *filePtrPtr = NULL;

        if (isClientTraceFile) {
            ts_clear_act(&(sgd.serverLogFileTS)); /* Clear T/S cell */
        } else {
            ts_clear_act(&(sgd.serverTraceFileTS)); /* Clear T/S cell */
        }

        if (closeErr != 0){
            getLocalizedMessageServer(CH_FCLOSE_FAILED_ON_TRACE,
                msgInsert, itoa(closeErr, digits, 8), SERVER_LOGS, msgBuffer);
                    /* 5242 The fclose() on the {0} trace file failed;
                       octal status {1} */
        }

        /* Set up a message for a successful command:
             The <server / client <id|tid>> trace was turned off
           This message is in sgd.textMessage, which is printed by the caller.
           In addition, add an entry to the server log file,
           indicating that the value was changed,
           and to the server's stdout file.
           addServerLogEntry's logIndicator argument controls the
           server log file and stdout.
           */
        msg2 = getLocalizedMessage(CH_TRACE_TURNED_OFF, msgInsert, NULL, 0, msgBuffer);
            /* 5243 The {0} trace was turned off */

        /* Eliminate the message number at the start of the message */
        checkForDigit(sgd.textMessage, msg2);

        addServerLogEntry(logIndicator, sgd.textMessage);

        if (wdePtr != NULL) {
            addClientTraceEntry(wdePtr, TO_CLIENT_TRACEFILE, sgd.textMessage);
        }

        /* Return 1, which tells the caller to print the message in
           sgd.textMessage
           */
        return 1;
    } /* end of TURN OFF processing */

    /* Common processing for the 'TURN ON' commands
       ('TURN ON SERVER TRACE' and 'TURN ON CLIENT id|tid TRACE').
       First see if the appropriate trace file is already open.
       */
    if (*filePtrPtr != NULL) {
        msg2 = getLocalizedMessageServer(CH_TRACE_ALREADY_ON, msgInsert, NULL,
            0, msgBuffer);
                /* 5244 The {0} trace is already turned on */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* See if we have a nonempty filename string */
    if (strlen(fileName) == 0) {
        /* There is no trace filename */
        msg2 = getLocalizedMessageServer(CH_NO_TRACE_FILE_SPECIFIED, msgInsert,
            NULL, 0, msgBuffer);
                /* 5245 No {0} trace file exists */
        strcpy(sgd.textMessage, msg2);
        return 1;
    }

    /* Is the trace file PRINT$? */
    if ((strcmp(fileName, PRINT$_FILE) == 0)){
    	/* For PRINT$ we use stdout as the trace file. */
    	localFilePtr = stdout;
    } else {
        /* Open the trace file in append mode */
        localFilePtr = fopen(fileName, "a");

        if (localFilePtr == NULL) {
            msg2 = getLocalizedMessageServer(CH_TRACE_FILE_NOT_OPENED, msgInsert, NULL, 0, msgBuffer);
                   /* 5246 Could not open the {0} trace file */
            strcpy(sgd.textMessage, msg2);
            return 1;
        }
    }

    /* Set the appropriate FILE pointer */
    if (! isClientTraceFile) {
        test_set(&(sgd.serverTraceFileTS)); /* Set the trace file's T/S cell */
    }

    *filePtrPtr = localFilePtr;

    if (! isClientTraceFile) {
        ts_clear_act(&(sgd.serverTraceFileTS)); /* Clear T/S cell */
    }

    /* If the trace file is not PRINT$, we need to do a @USE on the file name. */
    if ((strcmp(fileName, PRINT$_FILE) != 0)){
        /* Do an @USE for the trace file.
           It should never fail, since the file is open,
           and we have a valid USE name.
           */
        sprintf(sgd.textMessage, "@USE %s,%s . ", useName, fileName);

        useErr = doACSF(sgd.textMessage);

        if (useErr < 0) {
            getLocalizedMessageServer(CH_TRACE_FILE_USE_FAILED, msgInsert,
                itoa(useErr, digits, 8), SERVER_LOGS, msgBuffer);
                    /* 5207 @USE on {0} trace file name failed; octal status {1} */
        }
    }

    /* Set up a message for a successful command:
         The <server / client <id|tid>> trace was turned on
       This message is in sgd.textMessage, which is printed by the caller.
       In addition, add an entry to the server log file,
       indicating that the value was changed,
       and to the server's stdout file.
       addServerLogEntry's logIndicator argument controls the
       server log file and stdout.
       If we have the command 'TURN ON CLIENT id TRACE'
       also add an entry to the client trace file.
       */
    msg2 = getLocalizedMessage(CH_TRACE_TURNED_ON, msgInsert, NULL, 0, msgBuffer);
        /* 5247 The {0} trace was turned on */

    /* Eliminate the message number at the start of the message */
    checkForDigit(sgd.textMessage, msg2);

    addServerLogEntry(logIndicator, sgd.textMessage);

    if (wdePtr != NULL) {
        addClientTraceEntry(wdePtr, TO_CLIENT_TRACEFILE, sgd.textMessage);
    }

    /* Return 1, which tells the caller to print the message in
       sgd.textMessage
       */
    return 1;

} /* processTurnTraceCmd */
